const fs = require('fs');
const _  = require('lodash');

/**
 * Writes the result of a ctr instance to a file via fs
 * @param  {---} filePath -> Boolean, or option object. If boolean rather
 *                           than returning ctr this ref it returns the path
 *                           if wrote the results to
 * @param  {obj}  option  -> option object
 * @return {---}          -> Either string path, or ctr this ref
 */
const writeFile = function (filePath = false, option = {}) {
  const self = this;
  //check if rendered, if not inkove
  if (!self.rendered) {
    self._render();
  }
  //require path return if only arg === true
  if (filePath === true) {
    option.returnPath = true;
    filePath = false;
  }else if (_.isPlainObject(filePath)) {
    //option front loaded
    option = filePath;
    filePath = false;
  }

  //check for file path in option
  filePath = filePath ? filePath : option.filePath;
  //use file path of get calller file
  filePath = filePath ? filePath : self._getCallerFile();
  //check if user specifed a custom file name
  if (_.isString(option.fileName)) {
    filePath = filePath.replace(/\/([^\/]+)\/?$/, '/' + option.fileName);
  }

  //throw if wrong format
  if (!_.isString(filePath)) {
    self._throwErr({
      error: 'Format',
      msg: 'The writeFile method only accepts a string for the filepath. Current: ' + filePath
    });
    return self;
  }

  //gen or set comment
  let comment = null;
  if (_.isString(self.globalOption.get('comment')) || _.isString(option.comment)) {
    //custom comment
    comment = self.globalOption.get('comment') || option.comment;
  }else if (self.globalOption.get('comment') !== false && option.comment !== false) {
    //include file location of ctr call
    if (option.commentFile !== false && self.globalOption.get('commentFile') !== false) {
      //check if user specified a commentFile path as string otherwise get caller
      let ctrFn = _.isString(self.globalOption.get('commentFile')) || _.isString(option.commentFile)
                ? self.globalOption.get('commentFile')  || option.commentFile
                : false;
      //false means we want to autoGen
      if (ctrFn === false) {
        //get caller file and splice off the last three /
        //I don't really see the point on having a longer file path
        const fileCaller = self._getCallerFile();
        let pos = fileCaller.lastIndexOf('/');
        pos   = pos === -1 ? pos : fileCaller.lastIndexOf('/', pos - 1);
        pos   = pos === -1 ? pos : fileCaller.lastIndexOf('/', pos - 1);
        ctrFn = pos === -1 ? fileCaller : fileCaller.substring(pos);
        //addOn the little * at the end if there is room
        const addOn = 30 - ctrFn.length;
        if (addOn > 0) {
          for (let i = 0; i < addOn; i++) {
            ctrFn += ' ';
          }
          ctrFn += '*';
        }
      }
      //Probs want to do some fancy char length generation as some point
      comment = `/* --------------------------------------- *\n * NOTICE  : This CSS was generated by ctr *\n * DO NOT  : Do not, edit CSS directly     *\n * CTR LOC : ${ctrFn}\n * --------------------------------------- */`;
    }else {
      comment = `/* -------------------------------------- *\n * NOTICE : This CSS was generated by ctr *\n * DO NOT : Do not, edit CSS directly     *\n * -------------------------------------- */`;
    }
  }

  //replace file path
  filePath = filePath.replace(/\.[0-9a-z]+$/i, '.css');

  //get results
  let cssRes = self.getResult();
  if (comment !== null) {
    //append comment if present
    cssRes = comment + '\n\n\n' + cssRes;
  }

  //wrtie css file
  fs.writeFileSync(filePath, cssRes);

  //invoke option callback if once is provided
  if (option.callback && _.isFunction(option.callback)) {
    //pass along filePath for our friend
    return _.bind(option.callback, self)(filePath);
  }else if (option.returnPath || option.dynamicPath) {
    //format for a dynamic path
    if (option.dynamicPath) {
      filePath = filePath.replace(/\.[0-9a-z]+$/i, '');
      filePath = filePath.replace(/.*?\//i, '');
    }
    return filePath;
  }

  return self;
};


module.exports = writeFile;
